github repo:  https://github.com/nehashaw700/react-course

git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/nehashaw700/react_course.git   //this has to be done only once to add remote
git push -u origin main

package.json is a configuration for npm. keeps track of what version is installed.
bundler (webpack, parcel ) -> whole code needs to be bundled, cleaned, compressed.
dependencies -> dev dependency or -D
^ upgrades minor version automatically while ~ upgrades major version. Its safe to keep ^.

package-lock.json keeps a record of all exact version/dependencies installed

node_modules contains all the code that came from npm. Its kind of database of all dependencies.
Every dependency that we have installed have a package.json. which means it again has a set of dependencies. Hence, node modules bloats up.

package.json and package-lock.json can regenerate node modules via npm install. 
hence code of node_modules does not go into prod. .gitignore file tracks which file has to be ignored.
On server, node modules are not deployed. they are regenerated from package.json

npx parcel index.html // parcel has created a server for us and has build/ hosted an app on server

React is a js package. CDN links is not a preferred way of including react. as each time it would make network calls to the links which is costly.hence it would be good to have it inside our node_modules. // npm install react. No -D as we do not want it as dev dependency

Parcel:
Documentation: parceljs.org
* It automatically reloads when we save changes // HOT Module Replacement (HMR)
* It uses a file watching algo written in C++. 
* It keeps the track in cache file (.parcel-cache). which leads to faster builds
* Does image optimisation, minification , bundling, compressing
* Consistent Hashing
* Code Splitting
* Differential Bundling (support older browsers by generating nomodules bundles)
* Diagnostic
* Error Handling
* HTTPs
* Tree Shaking - remove unused code

dist: dist folder goes into production
dist, parcel-cache can be automatically regenerated. so it can be added inside node_module

browsers-lists: contains version list which are supported

npm run start () or npm start is same

------------------------------- xxxxxxxxxxxxxxxxxxxxxxxx ----------------------------------------

React COMPONENTS:
Class Based Components (Old)
Functional Components (New) -->
Normal JS Function which returns some JSX or react element

Component Composition => component inside a component

-------------------------------------------------------
Functional Component:
a normal js Function that returns a pc of jsx

Class based Component:
a normal js class which calls render() and returns a pc of jsx
extends React Component
pass props via constructor n call super(props) --> calling super() is mandate as reactComponent only then assigns props to this.props
state var creation -> this.state = { count : 0, sum = 0} // state will contain all the state vars count, sum;
Never update state vars directly -->
this.setState({
    count: this.state.count + 1;
    sum: this.state.sum + 1;
})
-----------------------------------------------------------------------------------
Lifecycle -> constructor() is called -> render() -> componentDidMount()
suppose we have 2 components parent n child
Parent Constructor()
Parent render() 

// inside render, parent encounter child comp. so Lifecycle of child comp is triggered.
Child Constructor() 
Child render()
Child componentDidMount()

// will be called when parent is completely rendered()
Parent componentDidMount() 


--------xxxxxxxxxxxxxxxxxxxxxxxx----------------------------
Lifecyle suppose we have 2 child components 
Parent Constructor()
Parent render() 

Child1 Constructor() 
Child1 render()

Child2 Constructor() 
Child2 render()

Child1 componentDidMount()
Child2 componentDidMount()

Parent componentDidMount() 

projects.wojtekmaj.pl/react-Lifecycle-methods-diagram
Has 2 phases: Render Phase , commit Phase
Constructor and Render is Render Phase
for two parallel child comp, reacts badges the render phase. hence renders for both the comp happens one after another. this is done for optimisation.
and calls commit phase, 

commit phase-> DOM updation/manipulation which is very expensive and time taking. hence react renders all child components at once and then moves to commit phase
DOM manipulation (in Single Batch)

This makes React fast.


-------------------------------------------------------

Use case of componentDidMount()
1. Make api calls here --> bcoz react does not wait for api calls and renders the component. so after the comp is rendered completely, we make api calls.
--------------------------------------------------------------------------

Custom Hooks:
Single Responsibility Principle --> good way of maintaining in a modular fashion
Code becomes reuseable, maintainable, testable

Building large scale application:
Bundlers bundles all the components/ files into a single js file. now if 1000s of components are bundled, size increases. 
Optimal solution -> Chunking/Code Splitting and Lazy Loading/ On demand Loading

--------------------------------------------------------------------------
Controlled and UnControlled Component
when a component is Controlled by parent
------------------------------------------------------------------------------------

REACT INTERVIEW TOPICS:

1. Diff btw useState and useRef? when to chose what?
    useState ad useRef both persists between re-renders but useRef doesn't render UI automatically when a useRef var is updated.
    useRef: can be updated directly
    useState: use Setters to update

    useRef is for:
    1. Storing DOM elements
    2. Storing mutable values without re-render
    3. Accesing previous values
    4. Avoiding Stale Closures

    should not useRef 
    1. as replacement for state variables
    2. For UI/ derived data

2. state vs props: both re-renders when changed. 
    state is mutable via setters. props not once received by child component
    props are some data/properties passed from parent to child component to show data
    state vars are hooks in React, which syncs the data layer with the UI layer.

3. Controlled and UnControlled Component
    Controlled: one which form-data/ behavior is controlled by React Component. we use useState hooks()
    UnControlled: stores form-data inside DOM. uses useRef()

4. useState, useRef, useMemo, useEffect, useCallback, custom Hooks
   useEffect: A hook in React enables the execution of side effects within functional components, such as fetching data, managing subscriptions, or directly interacting with the DOM. It serves as a substitute for lifecycle methods found in class components like componentDidMount, componentDidUpdate, and componentWillUnmount. 
   Will atleast run once when the component mounts

   Stale closures: when function remembers old data and never gets updated value. its kind of stuck in the past. 
 
   useMemo: 
   ‚úî Expensive calculations
    ‚úî Derived data
    ‚úî Preventing recalculation on every render

    Memoization: storing the result of an expensive function call in cache and returning it when same input is passed.Prevents recomputing and speed up the programs.

    const filteredUsers = useMemo(() => {
        return users.filter(u => u.active);
    }, [users]);

    useCallbacks: Memoizes functions and returns a stable function reference.

    useMemo and useCallback optimize performance

    High-Level Render Flow

    Whenever a component renders:

    1Ô∏è‚É£ React calls the component function
    2Ô∏è‚É£ Hooks run top ‚Üí bottom3Ô∏è‚É£ JSX is returned
    4Ô∏è‚É£ DOM is updated
    5Ô∏è‚É£ Effects run (after render)

5. virtual dom and reconciliation in REACT 

6. limitations of react in building large scale application
    React is a UI Library not a full framework. for many things like routing, state management (REDUX), form validation we need to use third-party libraries.
    For performance, we need to use bundlers, code-splitting, tree shaking.
    State management is diff with deeply nested components. if not managed properly, can lead to unnecessary renders.

7. React Router (protected routes, dynamic routing)
9. best practices for managing state in large apps?
10. How would you optimize performance in a React app with large component trees?
11. Code splitting, lazy loading, tree shaking
12. Component Lifecycle
13. Memoization

14. Explain React's Strict Mode and its impact on development.
    re-renders twice. runs side effects twice // happens to cleanup sideEffects
    this is dev only. doesn't happen in prod
    detects unsafe lifecycle method -> componentWillMount, componentWillUpdate

15. How can you prevent unnecessary re-renders in React functional components? -
    - React.Memo, useCallback, useMemo,
    - Keep state local
    - Avoid Storing Derived State
    - Use correct keys in iteration

16. Describe the key differences between functional and class components in React.

17. What is the significance of the React Fiber architecture?

18. How does React handle side effects, and how can you manage them effectively?

19. Explain the differences between `useMemo()` and `useCallback()` in React.

20. How would you implement dynamic form handling and validation in React?

21. What is lazy loading in React, and how does it improve application performance?

22. How would you handle errors in a React app, and what is the role of error boundaries? 

23. What are the benefits of server-side rendering (SSR) in React applications?

24. How do you handle styling in React components? Discuss different approaches.

25. How would you pass data between sibling components in React without using Redux?

26. Explain the use case of `useEffect()` for fetching data from an API.

27. How do you handle asynchronous operations in React using `async/await` or Promises?

28. How would you re-render a component when the window is resized?

29. Describe how React Context API can be used for state management in an app. //

30. Explain the difference between shallow and deep comparison in React's `shouldComponentUpdate`.

31. How do you handle asynchronous code execution and state updates in React?

32. What are higher-order components (HOCs) in React, and how are they used?

33. Explain React's reconciliation process and how it updates the DOM efficiently. 

34. Why does useEffect run twice on initial render in development? (Hint: React Strict Mode)

35. What‚Äôs the difference between useEffect(() => {}, []) and useEffect(() => {}, [state]) if state never changes?

36. Why might a component using React.memo still re-render? (Hint: referential equality)

37. Can useState updates be batched outside of event handlers? Why or why not?

38. What happens if you call a hook inside a conditional or a loop? Why exactly is it wrong?

39. How does useCallback help with React.memo and when does it become useless overhead?

40. What is the difference between useRef and useState when storing a mutable value?

41. Why is using setInterval inside useEffect tricky? What must you do to access latest state?

42. How can stale closures affect your useEffect or setTimeout calls?

43. Why might passing a function prop like onClick‚Äã={() => doSomething()} break memoization?

44. When does a component re-render even if state/props haven‚Äôt changed?

45. Why doesn't useEffect fire when a deeply nested object inside state changes?

46. What‚Äôs the actual difference between useEffect and useLayoutEffect in terms of timing?

47. How would you persist state across component unmounts without using Redux or context?

48. Can a useEffect cleanup function run after every render? When?

49. What‚Äôs the best way to debounce a value using hooks?

50. Why is using index as key in a list sometimes dangerous? Can you give a practical example?

51. What are the risks of using derived state in React?

52. How do you detect if a component is still mounted before calling setState in an async operation?

53. REST API and HTTP methods can react hooks fully replace redux for state management. why or why not? //
54. can react hooks fully replace redux for state management. why or why not? //
55. Redux flow(strore --> action --> reducer)
56. why redux over context


JavaScript Coding (MOST ASKED)
1Ô∏è‚É£ Implement debounce() from scratch - D
2Ô∏è‚É£ Implement throttle() from scratch - D
3Ô∏è‚É£ Flatten a deeply nested array and object both
4Ô∏è‚É£ Polyfill for map, filter, reduce, bind
5Ô∏è‚É£ Remove duplicates from an array (without using Set) - D
6Ô∏è‚É£ Deep clone an object 
7Ô∏è‚É£ Find the first non-repeating character in a string - D
8Ô∏è‚É£ Implement memoization
9Ô∏è‚É£ Convert callback-based function to Promise

 Currying for Infinite Sum
üëâ sum(10)(20)(30)() ‚Üí 60
üëâ sum(10)(20)(30)(40)(50)(60)() ‚Üí 210

üîπ React Coding (Live Round Favorites)
‚Ä¢ Build a counter with start / pause / reset
‚Ä¢ Create a search filter with debouncing
‚Ä¢ Implement infinite scrolling
‚Ä¢ Build a Todo app with add/edit/delete

‚Ä¢ Implement controlled vs uncontrolled input
‚Ä¢ Create sorting & pagination from scratch
‚Ä¢ Render a dynamic form from JSON
‚Ä¢ Implement lazy loading manually
‚Ä¢ Event delegation implementation
‚Ä¢ Build a modal from scratch (no libraries)
‚Ä¢ Drag & drop , dropdown using vanilla JS
‚Ä¢ Detect click outside an element


